# 2020.5.17～2020.5.X总结（unfinished）

## Day 0

入住，完全没有意识到自己要被吊锤

## Day 1

### T1

#### 题面

现在有$n+1$种等级的剑，编号为$0$到$n$，每个等级$i$有两个正整数属性$b_i,c_i$

锻造一把0级的剑需要$a$的花费，如果当前有一把等级为$i$的剑，以及一把等级为$\max\{i-1,0\}$（接下来用$j$表示）的剑，那么，有$\min\{b_j,c_i\}\over c_i$的概率得到一把等级为$i+1$的剑，否则得到一把$j$级的剑。

问得到一把等级为$n$的剑所需的期望花费是多少？

最终答案模$998244353$（是一个质数）.

$ 0\leq n\leq 10^7, \\\forall~~0\leq i\leq n, b_i\leq 10^7, c_i\leq 10^7$

#### 简单题解

可以发现，锻造失败时剩下了一把等级较小的剑，再次锻造只需要再次添加一把等级较大的剑，而等级较小的剑只需要一把，所以需要找到的是等级较大的剑需要的期望数量。

用$f(x)$表示得到一把等级为$x$的剑需要的期望花费。

假设锻造某种剑，一次锻造成功的概率为$p$，用$E$表示锻造成功所需要的次数，可以得到：
$$
E = p\times 1+(1-p)(E+1)=(1-p)E+1\\
E = {1\over p}
$$
那么可以得到：
$$
\begin{aligned}
f(x)&=E\times f(x-1)+f(\max\{x-2,0\})\\
&={c_{x-1}\over \min\{c_{x-1},b_{\max\{x-2,0\}}\}}\times f(x-1)+f(\max\{x-2,0\})
\end{aligned}
$$
线性求出逆元就好啦。

### T2

#### 题面

给定一个质数集合$S$，每个元素都不相同,用$n$表示其元素的乘积，同时给定一个正整数$m$,问满足
$$
n|x^m-x
$$
的，在区间$[1,n]$中的解的个数。
$$
\begin{aligned}
&|S| \leq 50, \\
&\forall p\in S,p\leq 10^4\\
&m\leq 10^9
\end{aligned}
$$


#### 不会

### T3

#### 题面

给定n个节点，现在有$m$个操作，保证所有操作完成之后，整个图是一个森林。

操作有下面两种：

1. 在给定的两个点之间连一条有向边，边权为$w$
2. 判断给定的两个节点中，第二个节点是否是第一个节点的祖先，如果是，则输出这两个点路径上边权最短的边，否则输出0

**强制在线**

#### 口糊题解

既然强制在线，那么可以使用$LCT$解决。。。记住不要写节点翻转

## Day 2

### T1

#### 题面

给出一个$N$个顶点的有向图，求有多少个长度小于$k$的环（环可以经过重复的结点），答案$\mod m$ 。

两个环不同当且仅当顶点序列不同。

$n\leq 35, k\leq 10^6$

#### 简单题解

原图可以看成一个01矩阵$A$，一个起止点为$i$的，长度为$k$的环可以表示为$A^k_{i,i}$，可以发现，如果我们在原图中增加一个点$n+1$，每次枚举一个起止点$i$,在$i$和$n+1$之间连接一条边，然后在$n+1$处做一个自环，那么以$i$为起止点，长度**小于**$k$的环的个数可以表示为$A^k_{i,n+1}-1$,这个$n+1$实际上表示停止增加环的长度，而$-1$是因为存在直接走到$n+1$然后停下来的方案。

>可以发现，如果出现一些图论的题目，点数特别少，然后存在类似走$k$步，长度不超过为$k$的路径数量之类的问题，可以考虑使用矩阵乘法。

### T2

#### 题面

 给一个$N$个顶点(编号$0$至$N-1$)，$N$条边的无向图，第$i$条边（i的范围从$0$至$N-1$）的长度是$L_i$，

第$i$条边是从结点i连向结点$V_i$的无向边。

现在已经在$M$个不同的顶点上分别建了城堡，第i个城堡建立在结点$C_i$。

你可以再选择不超过$K$个顶点建城堡。

要使每个顶点到最近城堡的距离的最大值最小。

$n\leq 35$

#### 乱搞题解

可以发现，$n$实在是小，只要预处理出点与点之间的距离，就能得到某个方法的最大距离。那么问题是，怎样才能得到方案数呢？

暴力找方案数实在是low，那么我们可以考虑一下模拟退火，每次随机在没有被选上的$n-m-K$个位置中选择一个位置随机替代其中的$K$个城堡。然后用两个循环计算出最大距离。

但是$delta$和$SA$的次数要好好调（我设置的是$delta=0.997,cnt=4$)，更新答案的时候要接受一些扰动小的次优解。

### T3

#### 题面

有一个N条边的凸多边形，N是偶数。

第i条边和第j条边被称为“对立边”的条件是：

第i条边和第j条边的两侧都是间隔着${N\over 2}-1$条边。



现在你要对整个二维平面颜色（一开始平面没有颜色）：

1、假设第$i$条边和第$j$条边是“对比边”。

2、过第i条边作一条直线，过第j条边作一条直线。

3、位于这两条直线之间的那部分区域，该区域如果包含凸多边形，那么给该区域颜色。



所有的染色结束之后，有$Q$个询问。

第i个询问是点$(X_i,Y_i)$是否在有颜色区域内，如果是输出“YES”，否则输出“NO”。

$1\leq n, q\leq 10^5$

**强制在线**

#### 还没看

## Day 3

先跳过这天

## Day 4

### T1

#### 题面

Farmer John 有 $N$个牧场，这些牧场通过 $N-1$条道路连接，形成了一个树形结构。

但在 28 年的经营后（译者注：USACO 创办于 1992 年），FJ 觉得处理树上问题非常辣手，他认为一条链上的问题更加简单。

因此他决定将整棵树划分为若干条链，将每一条链的管理权授予一位工人。他不关心链的数量，却关心链的长度，他希望划分的链都尽可能长，从而不会有人用效率低下的算法蒙混过关。

FJ 现在想知道最大的正整数 $K$，使得整棵树被划分成若干条链，且每条链的长度都**至少**是 $K$。

$n\leq 10^5$

#### 简单题解

看到最小值最大和最大值最小的字眼，可以考虑二分答案。

假设需要判定答案为$X$,类似某年$NOIP$ day1T3的做法，考虑一个节点$u$和它的儿子。现在儿子拉出了一些路径，将其路径长度都增加+1，组成一个集合$S$，那么所有长度小于$X$的路径,假设其中一条为$w$都必须和其他的路径合并，如果存在两条路径不能合并，那么就说明答案不能为$X$（因为只能上传一条路径）而寻找的另一条路径一定要和$X-w$最接近。

```cpp
const int maxn = 1e5 + 5;

struct Edge {
    int v, nex;
    Edge() {};
    Edge(int v, int nex) : v(v), nex(nex) {}
} E[maxn << 1];

int hd[maxn], tote;
void addedge(int u, int v) {
    E[++tote] = Edge(v, hd[u]), hd[u] = tote;
    E[++tote] = Edge(u, hd[v]), hd[v] = tote;
}

int n;
multiset<int> S[maxn];
bool succ; int tryX, len[maxn];

void dfs(int u, int fa) {
    S[u].clear(); bool exist_spath = false;
    for (int i = hd[u]; i; i = E[i].nex) {
        int v = E[i].v;
        if (v == fa) continue;
        dfs(v, u);
        if (!succ) return ;
        S[u].insert(len[v] + 1);
    }
    int sz = S[u].size();
    if ((u == 1 && (sz & 1)) || (u != 1 && !(sz & 1))) S[u].insert(0);
    while (!S[u].empty()) {
        multiset<int>::iterator it1, it2;
        int len1;
        it1 = S[u].begin(), len1 = *it1, S[u].erase(it1);
        it2 = S[u].lower_bound(tryX - len1);

        if (u == 1) {
            if (it2 == S[u].end()) { succ = false; break; }
            S[u].erase(it2);
        } else {
            if (it2 == S[u].end()) {
                if (exist_spath) { succ = false; break; }
                else exist_spath = true, len[u] = len1;
            } else S[u].erase(it2);
        }
    }
}

bool check(int X) {
    for (int i = 1; i <= n; i++) len[i] = 0;
    tryX = X, succ = true;
    dfs(1, -1);
    return succ;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v; scanf("%d%d", &u, &v);
        addedge(u, v);
    }
    int l = 1, r = n, ans = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) ans = mid, l = mid + 1;
        else r = mid - 1;
    }
    printf("%d\n", ans);
    return 0;
}
```

### T2

#### 题面

Farmer John 的农场可以用一个 $N\times N$的方阵（$1\leq N\leq 300$）。对于方阵内的每个格子，如果这个格子有奶牛，就用 `*` 表示，否则用 `.` 表示。

FJ 相信他的牧场的美丽程度正比于两两距离相等的奶牛三元组的数量。也就是说，她们组成一个等边三角形。不幸的是，直到最近 FJ 才发现，由于他的奶牛都处在整数坐标位置，如果使用欧几里得距离进行计算，不可能存在美丽的奶牛三元组！于是，FJ 决定改用“曼哈顿”距离。

给定表示奶牛位置的方阵，计算等边三角形的数量。

#### 题解

- 这只是一种可以通过卡常数完成的做法。
- 算法分析和代码实现的$y$轴增长方向相反。

考虑三个点能能够组成等边三角形的一种情况：

<img src="./Images/Day4 T2[1].png" style="zoom:50%;" />

可以得到：
$$
\begin{cases}
f+g=h+i=k+j\\
i = f+k\\j=g+h
\end{cases}
$$
接下来稍稍计算一下，可以得到一个特点：$f=g$

也就是说，$A,C$两点必须要和原图方框的对角线平行的一条直线上。接着观察如果$A,C$确定之后B的位置特点。

<img src="./Images/Day4 T2[2].png" style="zoom:50%;" />

接着像上面的图那样以$I$为共同的顶点，长宽分别为$2g$,$g$在同侧做两个长方形，如果点$I(x,y)$,那么$G(2g+x, y-g), H(x+g, y-2g)$,而所有的满足题目要求的点都在线段$HG$上，而点的数量可以使用前缀和求出，所以我们只需要枚举A，C其中一个点的位置和他们的坐标差，就能$O(1)$知道HG上究竟有多少个点。

还有，如果在调用前缀和结果的时候，不想写各种奇怪的边界处理，可以把前缀和的数组长宽各扩大一倍，而我们只需要计算大小为$2n^2$大小的矩阵（原图的，向下扩展的）即可，因为别的位置都是0。

这样我们就能在$O(n^3)$的情况下完成一种情况的计算，如果想要计算其他情况，可以将原图翻转90度。所以常数极大，需要在枚举坐标差的时候缩小一下范围，减少一下一些不必要的函数调用（比如结构体的构造就不要写了）